
&nbsp;&nbsp;이 프로젝트는 바닐라 자바스크립트로 카카오페이지 UI를 클론코딩하다 생긴 의문으로 시작하게 되었습니다. 프레임워크로 JS로 SPA를 구현하던 도중 state 변경에 의해 트리거 되는 재렌더링의 과정을 바닐라 자바스크립트로 구현해보고 싶다고 생각하게 되었고, 이 프로젝트를 통해 웹 컴포넌트부터, 상태관리, 가상 돔을 구현하며 자바스크립트에 대한 이해와 함께 리액트에 대해 깊이 있게 공부해보고자 합니다. 이번 프로젝트의 전체적인 진행은 황준일님의 [개발 블로그](https://junilhwang.github.io/TIL/Javascript/Design/Vanilla-JS-Component/#_2-state-setstate-render) 내용을 참고했습니다.

<br>

### 기본 기능 구현

&nbsp;&nbsp;먼저 리액트의 컴포넌트의 기능을 떠올려 보면, 컴포넌트는 UI를 표현하기 위한 `JSX` 구문과 상태(state)에 따라 UI가 변할 수 있으므로 `state`와 이를 설정하는 `setState`가 필요합니다. 아래 코드는 `state` 값이 변함에 따라 변경되는 UI를 표시하는 간단한 `Counter` 컴포넌트 코드입니다.

```javascript
// app.js
const $app = document.getElementById("app");

// state & setState
let state = {
  count: 0,
};

const setState = (newState) => {
  state = { ...state, ...newState };
};

// JSX에 대응
const template = () => {
  const { count } = state;
  return `
      <span>Count: ${count}</span>
      <button id="addTodo">추가</button>
    `;
};

// render로 DOM에 요소 추가 후 이벤트 등록
const registEvent = ($target) => {
  const { count } = state;
  document.getElementById("addTodo").addEventListener("click", () => {
    setState({ count: count + 1 });
    render($target);
  });  
}

// $target 요소 아래 UI 갱신
const render = ($target) => {
  $target.innerHTML = template();
  registEvent($target);
};

render($app);
```

<br>

&nbsp;&nbsp;`template`은 `JSX`에 대응되는 UI를 반환하는 함수로 호출 시 상태(state)값을 읽어와 이를 포함한 새로운 UI 값을 반환합니다. `render`함수는 `template`함수를 실행해 새롭게 화면에 띄울 내용을 가져와 `$target`요소에 삽입합니다. 만약 특정 요소에 이벤트를 추가해야 한다면 마지막에 해당 요소에 `addEventListener`를 통해 이벤트를 등록합니다.

<br>

### 추상화 및 모듈화

&nbsp;&nbsp;이제 위에서 구현한 컴포넌트의 전반적인 기능을 추상화를 통해 모든 컴포넌트에서 활용할 수 있도록 class를 통해 구현했습니다. 이렇게 구현한 컴포넌트를 활용해 가장 먼저 루트 컴포넌트인 `App`을 생성해주었습니다. 현재 `App`은 별도의 상태값을 가지 않고, 이후 `Counter` 컴포넌트를 포함할 것이기 때문에 `template` 메서드만 구현해주었습니다.

```javascript
// src/core/Component.js
export default class Component {
  $target;
  state;
  
  constructor($target) {
    this.$target = $target;
    this.init();
    this.render();
  }

  // state 등 초기화 작업 진행
  init() {}

  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.render();
  }

  // 반환할 UI 정의
  template() {
    return "";
  }

  // UI에 이벤트 등록
  setEvent() {}

  render() {
    this.$target.innerHTML = this.template();
  }
}

// src/App.js
import Component from "./core/Component.js";

export default class App extends Component {
  template() {
    return `
      <div>App Component</div>
    `;
  }
}
```

<br>
&nbsp;&nbsp;각 컴포넌트는 `Component`를 상속받으며 `Component`의 구조를 따라 각 컴포넌트 역시 구현의 방향성을 가지게 되었습니다. 이제 컴포넌트는 `Component` 클래스를 확장해 구현하므로 코드의 관리가 용이해졌습니다.

&nbsp;&nbsp;앞서 언급하지 않았지만 컴포넌트는 `src/component` 경로에, 리액트 기능을 구현할 모듈은 `src/core`에 위치해있습니다. 각 파일은 각자 수행할 기능을 담당하기 위해 파일 구조를 나누어 모듈화하도록 설계했습니다. 저의 경우 리액트에 익숙하기 때문에 리액트와 유사하게 `App` 컴포넌트를 루트 컴포넌트로 두고 `index.js`를 모듈의 시작점으로 설정했습니다.

```bash
.
├── index.html 
├── index.js ## ES Module 시작점
└── src
    ├── App.js ## Root Component
    ├── components
    │   └── Counter.js
    └── core ## 리액트 기능 구현을 위한 core module
        └── Component.js
```

<br>

```javascript

```
<br>

**References**
- [Vanilla Javascript로 웹 컴포넌트 만들기](https://junilhwang.github.io/TIL/Javascript/Design/Vanilla-JS-Component/)