📄 **비트마스킹**
===================
## **비트 연산자**
- 비트 AND 연산(&) : 대응되는 비트가 모두 1이면 1을 반환
- 비트 OR 연산(|) : 대응되는 비트 중에서 하나라도 1이면 1을 반환
- 비트 XOR 연산(^) : 대응되는 비트가 서로 다르면 1을 반환
- 비트 NOT 연산(~) : 비트가 1이면 0으로, 0이면 1로 반전
- 비트 LEFT SHIFT 연산(<<) : 지정된 수만큼 비트들을 전부 왼쪽으로 이동
- 비트 RIGHT SHIFT 연산(>>) : 지정된 수만큼 비트들을 전부 오른쪽으로 이동
<br/><br/>

## **조합과 비트마스킹**
&nbsp;&nbsp;비트 LEFT SHIFT 연산을 사용하면 $2^N$을 표현할 수 있다. N개 데이터의 조합의 경우 $2^N$개의 조합이 나오는데 1을 N번 LEFT SHIFT 연산한 값은 $2^N$와 동일하다는 성질을 이용한 것이다.
<br/><br/>

&nbsp;&nbsp;또한 i의 2진수와 1을 j번 LEFT SHIFT한 수의 AND(&) 연산값이 0보다 크면 j번째 값의 포함 여부를 확인할 수 있는데 이는 비트 AND(&) 연산의 결과로 해당 비트 위치에 1이 포함되어있는지를 확인할 수 있다는 것을 이용한 것이다.
<br/><br/>

```
0101 (1번째, 3번째 요소가 포함된 조합)
0100 (1을 2번 LEFT SHIFT, 3번째 요소 확인)
---- ( & 연산 )
0100 -> 0보다 크므로 3번째 요소가 포함되었음을 확인
```

```java
// LEFT SHIFT 연산을 사용해 2^N개의 조합 쌍을 탐색
for (int i=0; i<(1<<N); i++) {
    for (int j=0; j<N; j++) {
        if ( (i & (1 << j)) > 0) {
            /* j번째 요소 포함 */
        }
    }
}
```
<br/><br/>

## **순열과 비트마스킹**
&nbsp;&nbsp;N개의 요소에서 R개를 뽑아 순열을 만드는 가지수는 $N!/(N - R)!$ 이다. 5개의 요소에 대해 각각 뽑았으면 1, 뽑지 않았다면 0이라고 한다면 비트는 모두 뽑지 않는 00000부터, 5개를 모두 뽑은 11111의 범위 내에서 움직이게 된다.
<br/><br/>

&nbsp;&nbsp;아래 코드는 비트마스킹을 사용해 순열을 생성하는 예시이다. idx는 현재 몇 번째(idx ~0부터) 요소를 뽑을 차례인지를 의미하는 변수이며, isVisited는 위에서 언급한(전체 요소 5개를 기준으로) 00000(0)부터 11111(31)까지 현재 뽑은 것과 뽑지 않은 것을 나타낼 비트이다.
<br/><br/>

&nbsp;&nbsp;해당 요소에 방문했는지는 i번째 요소에 접근한다 했을 때 1을 i번 LEFT SHIFT 연산을 시행한 것과 isVisited의 뒤에서부터 i번째 요소를 비교해 1이면(0이 아니라면) 방문한 것이고 0이면 방문하지 않았음을 알 수 있다.
<br/><br/>

&nbsp;&nbsp;방문 체크를 해서 이전에 방문하지 않았었다면 해당 요소를 뽑고 재귀를 호출하는데 isVisited에서 i번째 요소를 선택했으므로 i번쨰 위치를 1로 교체하면 되는데 이는 isVisited와 1을 i번 LEFT SHIFT 연산한 숫자의 OR(|) 연산을 하면 된다.
<br/><br/>

```java
/* N개의 요소에서 N개를 골라 순열을 만드는 경우 */
static void permutation(int idx, int isVisited) {
    if (idx == N) {
        /* 순열 생성 완성 */
        return;
    }
    
    for (int i=0; i<N; i++) {
        if ((isVisited & (1 << i)) != 0) continue;
        
        result[idx] = nums[i];
        permutation(idx + 1, isVisited | (1 << i));
    }
}
```