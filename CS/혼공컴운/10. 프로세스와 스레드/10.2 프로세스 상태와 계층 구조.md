## 10.2 프로세스 상태와 계층 구조

### 프로세스 상태

&nbsp;&nbsp;프로세스는 여러 상태를 거치며 실행되며 운영체제는 PCB를 통해 해당 프로세스의 상태를 인식하고 관리합니다. 프로세스의 상태는 운영체제마다 다르게 표현될 수 있지만 프로세스가 가질 수 있는 대표적인 상태는 다음과 같습니다.

<br>

**1. 생성 상태(new)**

- 프로세스를 생성 중인 상태로 이제 막 메모리에 적재되어 PCB를 할당받은 상태를 말합니다.

- `생성 상태`를 거친 프로세스는 바로 실행되지 않고 다음으로 `준비 상태`가 되어 CPU의 할당을 기다립니다.

<br>

**2. 준비 상태(ready)**

- 차례가 되어 CPU를 할당받기 전까지 대기 중인 상태입니다.

- `준비 상태`에서 CPU를 할당받아 실행 상태로 전환되는 과정을 `디스패치(dispatch)`라고 부릅니다.

<br>

**3. 실행 상태(running)**

- CPU를 할당받아 실행 중인 상태입니다.

- `실행 상태`인 프로세스는 일정 시간 동안 CPU를 사용할 수 있습니다.
- 할당된 시간이 지나 타이머 인터럽트가 발생하면 다시 준비 상태가, 실행 도중 입출력장치를 사용하여 입출력장치의 작업을 기다린다면 `대기 상태`가 됩니다.

<br>

**4. 대기 상태(blocked)**

- 프로그램 실행 도중 입출력장치를 사용하는 경우 입출력장치의 처리 속도가 CPU에 비해 느리기 때문에 해당 프로세스는 입출력장치의 작업 완료를 기다리는 `대기 상태`로 전환됩니다.

- 입출력장치의 작업이 완료되면 해당 프로세스는 다시 CPU 할당을 기다리는 `준비 상태`가 됩니다.

<br>

**5. 종료 상태(terminated)**

- 프로세스가 종료된 상태로 운영체제는 PCB와 프로세스가 사용한 메모리를 정리합니다.

<br>

&nbsp;&nbsp;아래의 도표는 전반적인 프로세스 흐름을 그래프로 표시한 `프로세스 상태 다이어그램(process state diagram)`입니다. 컴퓨터 내의 여러 프로세스는 생성, 준비, 실행, 대기, 종료 상태를 거치며 실행되며 운영체제는 상태들을 PCB에 저장하여 프로세스들을 관리합니다.

<figure align="center">
  <img src="../images/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%83%81%ED%83%9C%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8.jpg" style="width: 600px" />
</figure>

<br>

### 프로세스 계층 구조

&nbsp;&nbsp;프로세스는 실행 중에 시스템 호출을 통해 다른 프로세스를 생성할 수 있습니다. 새 프로세스를 생성한 프로세스를 `부모 프로세스(parent process)`, 생성된 프로세스를 `자식 프로세스(child process)`라고 부릅니다.

<br>

> 💡 자식 프로세스 중에서는 부모 프로세스의 PID인 PPID(parent PID)를 저장하고 있는 경우도 있습니다.

<br>

&nbsp;&nbsp;이렇게 계속해서 시스템 호출을 통해 자식 프로세스를 생성하게 되면 트리 구조의 계층 구조가 만들어지게 되는데 이것을 `프로세스 계층 구조`라고 합니다.

<br>

### 프로세스 생성 기법

&nbsp;&nbsp;부모 프로세스가 자식 프로세스를 생성하는 방법은 `복제`와 `옷 갈아입기` 과정을 통해 실행됩니다. 순서대로 과정을 설명하면,

<br>

**프로세스 생성 과정**

1. 부모 프로세스는 `fork` 시스템 호출을 통해 자신의 복제본을 자식 프로세스로 생성합니다. 메모리 내용이나 열린 파일의 목록 등 부모 프로세스의 자원은 자식 프로세스에 상속됩니다.

2. 자식 프로세스(복사본)은 `exec` 시스템 호출을 통해 자신의 메모리 공간을 다른 프로그램으로 교체합니다. 자신의 메모리 공간을 새로운 프로그램 내용으로 `덮어 쓰기` 때문에 옷 갈아입기를 했다고 표현합니다. `exec`를 호출하면 코드 영역과 데이터 영역은 실행할 프로그램으로 바뀌고 나머지 영역은 초기화 됩니다.

<br>

> 💡 때로는 부모 프로세스와 자식 프로세스 모두 `exec`를 호출하지 않는 경우도 있습니다. 이 때에는 부모와 자식 프로세스 모두 같은 코드를 병행하여 실행하는 프로세스가 됩니다.

<br>
