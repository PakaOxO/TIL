## 03.2 명령어의 구조

### 연산 코드와 오퍼랜드

- 명령어는 어떤 동작을 수행할지(연산 코드)와 무엇을 대상으로 할지(오퍼랜드)의 구조로 이루어져 있습니다.
- `연산 코드`는 <mark>명령어가 수행할 연산</mark>을, `오퍼랜드`는 <mark>연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치</mark>를 가리킵니다.
- 연산 코드는 연산자, 오퍼랜드는 피연산자라고도 부릅니다.
- 메모리에서 연산 코드가 담기는 영역을 `연산 코드 필드`, 오퍼랜드가 담기는 영역을 `오퍼랜드 필드`라고 합니다.
- 아래 어셈블리어의 예시로 좌측이 연산 코드, 우측이 오퍼랜드입니다.

<br>

**어셈블리어 예시**

<p align="left" style="width: 400px; margin: 0 auto">
  <span style="color: red">push</span>&nbsp;&nbsp;&nbsp;rbp
  <br>
  <span style="color: red">mov</span>&nbsp;&nbsp;&nbsp;rbp, rsp
  <br>
  <span style="color: red">mov</span>&nbsp;&nbsp;&nbsp;DWORD PTR [rbp-4], 1
  <br>
  <span style="color: red">mov</span>&nbsp;&nbsp;&nbsp;DWORD PTR [rbp-8], 2
  <br>
  <span style="color: red">mov</span>&nbsp;&nbsp;&nbsp;edx, DWORD PTR [rbp-4]
  <br>
  <span style="color: red">mov</span>&nbsp;&nbsp;&nbsp;edx, DWORD PTR [rbp-8]
  <br>
  <span style="color: red">add</span>&nbsp;&nbsp;&nbsp;eax, edx
  <br>
  <span style="color: red">mov</span>&nbsp;&nbsp;&nbsp;DWORD PTR [rbp-12], eax
  <br>
  <span style="color: red">pop</span>&nbsp;&nbsp;&nbsp;rbp
  <br>
  <span style="color: red">ret</span>
</p>

<br>

**오퍼랜드**

- 오퍼랜드는 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치를 의미합니다.
- 오퍼랜드 필드에는 숫자, 문자와 같이 연산에 사용할 데이터를 직접 명시할 수 있지만 일반적으로 연산에 사용할 데이터가 저장된 위치인 `메모리 주소`나 `레지스터 이름`이 담깁니다.
- 오퍼랜드 필드는 `주소 필드`라 부르기도 합니다.
- 오퍼랜드 필드에 어떤 주소가 올지는 이후 설명할 <mark>주소 지정 방식</mark>에 따라 다릅니다.
- 오퍼랜드는 명령어 안에 없을 수도, 한 개 이상이 올 수도 있습니다. 오퍼랜드의 개수에 따라 명령어는 `0-주소 명령어`, `1-주소 명령어`, `2-주소 명령어`, `3-주소 명렁어` 라고 부릅니다.

<br>

**연산 코드**

- 연산 코드의 종류는 다양한지만 가장 기본적인 연산 코드는 다음과 같습니다.

<br>

> 1. 데이터 전송
> 2. 산술/논리 연산
> 3. 제어 흐름 변경
> 4. 입출력 제어

<br>

- 명령어의 종류와 생김새는 CPU에 따라 다르기 때문에 연산 코드의 종류와 생김새 역시 CPU에 따라 달라집니다.

<br>

### 주소 지정 방식

- 오퍼랜드 필드에 데이터를 직접 담아 사용했을 때의 단점은 명령어의 크기가 N비트라고 했을 때, 1-주소 지정 방식이라 가정했을 때 오퍼랜드에 담을 수 있는 최대 데이터 크기는 명령어 필드의 크기 M을 제외한 (N - M)비트로 제한됩니다.
- 주소 지정 방식은 오퍼랜드 필드에 메모리 주소를 담아 <mark>데이터의 크기를 하나의 메모리 주소에 저장할 수 있는 공간만큼 확장</mark>할 수 있다는 장점이 있습니다.
- 이는 오퍼랜드 필드에 레지스터의 이름을 명시할 때에도 마찬가지입니다.
- 연산 코드에 사용할 데이터가 저장된 위치를 `유효 주소(effective address)`라고 부릅니다.
- 정리하면 `주소 지정 방식`은 <mark>유효 주소를 찾아 연산에 필요한 데이터를 찾는 방식</mark>을 가리킵니다.

<br>

**1. 즉시 주소 지정 방식**

- `즉시 주소 지정 방식(immediate addressing mode)`는 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식입니다.
- 오퍼랜드 크기에 제한되어 <mark>사용할 수 있는 크기에 제약</mark>이 있다는 단점이 있지만 데이터를 메모리나 레지스터로부터 찾는 과정이 없어 <mark>다른 주소 지정 방식들보다 빠릅니다.</mark>

<br>

**2. 직접 주소 지정 방식**

- `직접 주소 지정 방식(direct addressing mode)`는 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식입니다.
- 즉시 주소 지정 방식에 비해 표현할 수 있는 데이터의 크기가 증가했지만, 오퍼랜드의 크기에 따라 지정할 수 있는 유효 주소에 제한이 생긴다는 문제가 남아 있습니다.

<br>

**3. 간접 주소 지정 방식**

- `간접 주소 지정 방식(indirect addressing mode)`는 유효 주소가 담긴 메모리의 주소를 오퍼랜드 필드에 명시하는 방식입니다.
- 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 큽니다.
- 연산에 필요한 데이터에 접근하기 위해 유효 주소를 담은 메모리와 다시 유효 주소가 가리키는 메모리, <mark>2번의 메모리 접근이 필요</mark>하다는 관점에서 일반적으로 다른 주소 지정 방식에 비해 속도는 느립니다.

<br>

**4. 레지스터 주소 지정 방식**

- 만약 연산에 사용되는 데이터가 메모리가 아닌 레지스터에 저장되어 있다면 `레지스터 주소 지정 방식(register addressing mode)`를 사용할 수 있습니다.
- 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시합니다.
- CPU 외부에 있는 메모리보다, CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르기 때문에 레지스터 주소 지정 방식은 <mark>직접 주소 지정 방식보다 빠르게 데이터에 접근</mark>할 수 있습니다.
- 직접 주소 지정 방식과 마찬가지로 오퍼랜드 필드 크기에 의해 <mark>표현할 수 있는 레지스터 크기에 제약</mark>이 있습니다.

<br>

**5. 레지스터 간접 주소 지정 방식**

- `레지스터 간접 주소 지정 방식(register indirect addressing mode)`는 연산에 사용되는 데이터를 메모리에 저장하고 그 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방식입니다.
- 간접 주소 지정 방식과 비슷하지만 메모리에 접근하는 횟수는 한 번으로 나머지 한번은 레지스터에 접근하기 때문에 간접 주소 지정 방식에 비해 빠릅니다.

<br>
